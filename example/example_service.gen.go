// Code generated by nrpc; DO NOT EDIT.

package example

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/nats-io/nats.go"
	"sync"
	"time"
)

// Response wrapper type for ExampleService.Time
type exampleServiceTimeResponse struct {
	Ok  time.Time                `json:"ok"`
	Err *ExampleServiceTimeError `json:"err"`
}

// Response wrapper type for ExampleService.Echo
type exampleServiceEchoResponse struct {
	Ok  string                   `json:"ok"`
	Err *ExampleServiceEchoError `json:"err"`
}

// Response wrapper type for ExampleService.Restart
type exampleServiceRestartResponse struct {
	Err *ExampleServiceRestartError `json:"err"`
}

type ExampleServiceTimeError struct {
	Message string
}

func (err *ExampleServiceTimeError) Error() string {
	return fmt.Sprintf("ExampleService.Time: %s", err.Message)
}

func (err *ExampleServiceTimeError) Is(other error) bool {
	_, is := other.(*ExampleServiceTimeError)
	return is
}

type ExampleServiceEchoError struct {
	Message string
}

func (err *ExampleServiceEchoError) Error() string {
	return fmt.Sprintf("ExampleService.Echo: %s", err.Message)
}

func (err *ExampleServiceEchoError) Is(other error) bool {
	_, is := other.(*ExampleServiceEchoError)
	return is
}

type ExampleServiceRestartError struct {
	Message string
}

func (err *ExampleServiceRestartError) Error() string {
	return fmt.Sprintf("ExampleService.Restart: %s", err.Message)
}

func (err *ExampleServiceRestartError) Is(other error) bool {
	_, is := other.(*ExampleServiceRestartError)
	return is
}

// Client for accessing ExampleService over NATS RPC
type exampleServiceClient struct {
	options *ClientOptions
	conn    *nats.Conn
}

// Create a new client that transparently accesses ExampleService over NATS RPC
func NewExampleServiceClient(conn *nats.Conn, options ...ClientOpt) (ExampleService, error) {
	opts := &ClientOptions{Timeout: 10 * time.Second}
	for _, option := range options {
		if err := option.setClient(opts); err != nil {
			return nil, err
		}
	}
	return &exampleServiceClient{
		conn:    conn,
		options: opts,
	}, nil
}

// Implements ExampleService.Time
func (client *exampleServiceClient) Time() (response time.Time, err error) {
	// Send RPC message to ExampleService.Time
	msg, err := client.conn.Request(client.options.Namespace+"ExampleService.Time", nil, client.options.Timeout)
	if err != nil {
		return response, err
	}

	// Decode response into a wrapper object
	var reswrap exampleServiceTimeResponse
	if err := json.NewDecoder(bytes.NewReader(msg.Data)).Decode(&reswrap); err != nil {
		return response, err
	}

	if reswrap.Err != nil {
		return reswrap.Ok, reswrap.Err
	}
	return reswrap.Ok, nil
}

// Implements ExampleService.Echo
func (client *exampleServiceClient) Echo(message string) (response string, err error) {
	// Encode request data from string using gob
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(&message); err != nil {
		return response, err
	}

	// Send RPC message to ExampleService.Echo
	msg, err := client.conn.Request(client.options.Namespace+"ExampleService.Echo", buf.Bytes(), client.options.Timeout)
	if err != nil {
		return response, err
	}

	// Decode response into a wrapper object
	var reswrap exampleServiceEchoResponse
	if err := json.NewDecoder(bytes.NewReader(msg.Data)).Decode(&reswrap); err != nil {
		return response, err
	}

	if reswrap.Err != nil {
		return reswrap.Ok, reswrap.Err
	}
	return reswrap.Ok, nil
}

// Implements ExampleService.Restart
func (client *exampleServiceClient) Restart() (err error) {
	// Send RPC message to ExampleService.Restart
	msg, err := client.conn.Request(client.options.Namespace+"ExampleService.Restart", nil, client.options.Timeout)
	if err != nil {
		return err
	}

	// Decode response into a wrapper object
	var reswrap exampleServiceRestartResponse
	if err := json.NewDecoder(bytes.NewReader(msg.Data)).Decode(&reswrap); err != nil {
		return err
	}

	if reswrap.Err != nil {
		return reswrap.Err
	}
	return nil
}

// Expose a ExampleService implementation over NATS RPC
type exampleServiceServer struct {
	options *ServerOptions
	service ExampleService
	conn    *nats.Conn
	// Internal-only fields
	lock sync.Mutex
	stop chan struct{}
	errs chan error
}

// Create a new server that exposes ExampleService over NATS RPC
func NewExampleServiceServer(service ExampleService, conn *nats.Conn, options ...ServerOpt) (Server, error) {
	opts := new(ServerOptions)
	for _, option := range options {
		if err := option.setServer(opts); err != nil {
			return nil, err
		}
	}

	return &exampleServiceServer{
		conn:    conn,
		options: opts,
		service: service,
	}, nil
}

// Start the RPC server that wraps ExampleService
func (server *exampleServiceServer) Start() error {
	server.lock.Lock()
	defer server.lock.Unlock()

	// We're already running, so don't do anything
	if server.stop != nil {
		return nil
	}

	// Create a stop signal channel
	server.stop = make(chan struct{})

	// Create a channel for handling errors.
	server.errs = make(chan error)
	go func() {
		for err := range server.errs {
			// Only do something if we have an error handler
			if server.options.ErrorHandler != nil {
				server.options.ErrorHandler(err)
			}
		}
	}()

	// Start Time server loop
	if err := server._serve(server.options.Namespace+"ExampleService.Time", server.handleTime); err != nil {
		close(server.stop)
		close(server.errs)
		return err
	}

	// Start Echo server loop
	if err := server._serve(server.options.Namespace+"ExampleService.Echo", server.handleEcho); err != nil {
		close(server.stop)
		close(server.errs)
		return err
	}

	// Start Restart server loop
	if err := server._serve(server.options.Namespace+"ExampleService.Restart", server.handleRestart); err != nil {
		close(server.stop)
		close(server.errs)
		return err
	}

	return nil
}

// Stop the RPC server that wraps ExampleService
func (server *exampleServiceServer) Stop() error {
	server.lock.Lock()
	defer server.lock.Unlock()

	// We're not running, so do nothing.
	if server.stop == nil {
		return nil
	}

	// Stop all workers, clean up subscriptions
	close(server.stop)
	close(server.errs)
	server.stop = nil
	server.errs = nil
	return nil
}

func (server *exampleServiceServer) _serve(subject string, handler func(*nats.Msg)) error {
	msgs := make(chan *nats.Msg, server.options.BufferSize)
	sub, err := server.conn.ChanSubscribe(subject, msgs)
	if err != nil {
		return err
	}
	fmt.Println("Listening on:", subject)

	// Remove the subscription and clean up when
	// the stop channel is closed
	go func() {
		<-server.stop
		if err := sub.Unsubscribe(); err != nil {
			server.errs <- err
		}
		close(msgs)
	}()

	go func() {
		// Handle incoming server messages
		for msg := range msgs {
			handler(msg)
		}
	}()
	return nil
}

// Exposes ExampleService.Time via NATS RPC
func (server *exampleServiceServer) handleTime(msg *nats.Msg) {
	defer func() {
		if val := recover(); val != nil {
			if err, ok := val.(error); ok {
				server.errs <- err
			}
		}
	}()
	var response exampleServiceTimeResponse
	if res, err := server.service.Time(); err != nil {
		errw := &ExampleServiceTimeError{err.Error()}
		response.Err = errw
		server.errs <- errw
	} else {
		response.Ok = res
	}

	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(response); err != nil {
		server.errs <- &ExampleServiceTimeError{err.Error()}
	} else if err := msg.Respond(buf.Bytes()); err != nil {
		server.errs <- &ExampleServiceTimeError{err.Error()}
	}
}

// Exposes ExampleService.Echo via NATS RPC
func (server *exampleServiceServer) handleEcho(msg *nats.Msg) {
	defer func() {
		if val := recover(); val != nil {
			if err, ok := val.(error); ok {
				server.errs <- err
			}
		}
	}()
	var request string
	var response exampleServiceEchoResponse
	if err := json.NewDecoder(bytes.NewReader(msg.Data)).Decode(&request); err != nil {
		errw := &ExampleServiceEchoError{err.Error()}
		response.Err = errw
		server.errs <- errw
	} else if res, err := server.service.Echo(request); err != nil {
		errw := &ExampleServiceEchoError{err.Error()}
		response.Err = errw
		server.errs <- errw
	} else {
		response.Ok = res
	}

	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(response); err != nil {
		server.errs <- &ExampleServiceEchoError{err.Error()}
	} else if err := msg.Respond(buf.Bytes()); err != nil {
		server.errs <- &ExampleServiceEchoError{err.Error()}
	}
}

// Exposes ExampleService.Restart via NATS RPC
func (server *exampleServiceServer) handleRestart(msg *nats.Msg) {
	defer func() {
		if val := recover(); val != nil {
			if err, ok := val.(error); ok {
				server.errs <- err
			}
		}
	}()
	var response exampleServiceRestartResponse
	if err := server.service.Restart(); err != nil {
		errw := &ExampleServiceRestartError{err.Error()}
		response.Err = errw
		server.errs <- errw
	}

	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(response); err != nil {
		server.errs <- &ExampleServiceRestartError{err.Error()}
	} else if err := msg.Respond(buf.Bytes()); err != nil {
		server.errs <- &ExampleServiceRestartError{err.Error()}
	}
}
