// Code generated by nrpc; DO NOT EDIT.

package example

import (
	"errors"
	"fmt"
	"github.com/egoodhall/nrpc/go/pkg/nrpc"
	"github.com/nats-io/nats.go"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"
	"sync"
)

type ExampleService interface {
	Echo(*EchoRequest) (*EchoReply, error)
}

func NewExampleServiceClient(conn *nats.Conn, options ...nrpc.ClientOption) (ExampleService, error) {
	clientOptions, err := nrpc.NewClientOptions(options...)
	if err != nil {
		return nil, err
	}

	return &exampleServiceClient{
		conn:    conn,
		options: clientOptions,
	}, nil
}

type exampleServiceClient struct {
	options *nrpc.ClientOptions
	conn    *nats.Conn
}

func (client *exampleServiceClient) Echo(request *EchoRequest) (*EchoReply, error) {
	requestwrap := new(nrpc.RequestWrapper)

	datapb, err := anypb.New(request)
	if err != nil {
		return nil, err
	}
	requestwrap.Data = datapb

	data, err := requestwrap.MarshalVT()
	if err != nil {
		return nil, err
	}

	resmsg, err := client.conn.Request(client.options.ApplyNamespace("ExampleService.Echo"), data, client.options.Timeout)
	if err != nil {
		return nil, err
	}

	responsewrap := new(nrpc.ResponseWrapper)
	if err := responsewrap.UnmarshalVT(resmsg.Data); err != nil {
		return nil, err
	}

	switch response := responsewrap.Data.(type) {
	case *nrpc.ResponseWrapper_Ok:
		ok := new(EchoReply)
		if err := response.Ok.UnmarshalTo(ok); err != nil {
			return nil, err
		}
		return ok, nil
	case *nrpc.ResponseWrapper_Err:
		return nil, errors.New(response.Err)
	default:
		return nil, fmt.Errorf("unsupported response type: %T", response)
	}
}

func NewExampleServiceServer(conn *nats.Conn, service ExampleService, options ...nrpc.ServerOption) (nrpc.Server, error) {
	serverOptions, err := nrpc.NewServerOptions(options...)
	if err != nil {
		return nil, err
	}

	return &exampleServiceServer{
		conn:    conn,
		options: serverOptions,
		service: service,
	}, nil
}

type exampleServiceServer struct {
	options *nrpc.ServerOptions
	service ExampleService
	conn    *nats.Conn
	// Internal only fields
	lock sync.Mutex
	stop chan struct{}
	errs chan error
}

func (server *exampleServiceServer) Start() error {
	server.lock.Lock()
	defer server.lock.Unlock()

	// We're already running, so don't do anything
	if server.stop != nil {
		return nil
	}

	// Create a stop signal channel
	server.stop = make(chan struct{})

	// Create a channel for handling errors.
	server.errs = make(chan error)
	go func() {
		for err := range server.errs {
			// Only do something if we have an error handler
			if server.options.ErrorHandler != nil {
				server.options.ErrorHandler(err)
			}
		}
	}()

	// Start Echo server loop
	if err := server.startSubscription(server.options.ApplyNamespace("ExampleService.Echo"), server.serveEcho); err != nil {
		close(server.stop)
		close(server.errs)
		return err
	}

	return nil
}

// Stop the RPC server that wraps ExampleService
func (server *exampleServiceServer) Stop() error {
	server.lock.Lock()
	defer server.lock.Unlock()

	// We're not running, so do nothing.
	if server.stop == nil {
		return nil
	}

	// Stop all workers, clean up subscriptions
	close(server.stop)
	close(server.errs)
	server.stop = nil
	server.errs = nil
	return nil
}

func (server *exampleServiceServer) startSubscription(subject string, handler func(*nats.Msg)) error {
	msgs := make(chan *nats.Msg, server.options.BufferSize)

	sub, err := server.conn.ChanQueueSubscribe(subject, server.options.QueueGroup, msgs)
	if err != nil {
		return err
	}
	fmt.Println("Listening on:", subject)

	// Remove the subscription and clean up when
	// the stop channel is closed
	go func() {
		<-server.stop
		if err := sub.Unsubscribe(); err != nil {
			server.errs <- err
		}
		close(msgs)
	}()

	go func() {
		// Handle incoming server messages
		for msg := range msgs {
			handler(msg)
		}
	}()
	return nil
}

func (server *exampleServiceServer) serveEcho(msg *nats.Msg) {
	request := new(EchoRequest)
	requestwrap := new(nrpc.RequestWrapper)
	responsewrap := new(nrpc.ResponseWrapper)

	if err := requestwrap.UnmarshalVT(msg.Data); err != nil {
		responsewrap.Data = &nrpc.ResponseWrapper_Err{Err: err.Error()}
		server.errs <- err
	} else if err := anypb.UnmarshalTo(requestwrap.Data, request, proto.UnmarshalOptions{}); err != nil {
		responsewrap.Data = &nrpc.ResponseWrapper_Err{Err: err.Error()}
		server.errs <- err
	} else if response, err := server.service.Echo(request); err != nil {
		responsewrap.Data = &nrpc.ResponseWrapper_Err{Err: err.Error()}
		server.errs <- err
	} else if datapb, err := anypb.New(response); err != nil {
		responsewrap.Data = &nrpc.ResponseWrapper_Err{Err: err.Error()}
		server.errs <- err
	} else {
		responsewrap.Data = &nrpc.ResponseWrapper_Ok{Ok: datapb}
	}

	// Send our response back
	if data, err := responsewrap.MarshalVT(); err != nil {
		server.errs <- err
	} else if err := msg.Respond(data); err != nil {
		server.errs <- err
	}
}
