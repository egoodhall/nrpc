package render

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	"github.com/emm035/nrpc/go/internal/parse"
	"github.com/iancoleman/strcase"
	"github.com/sourcegraph/conc/pool"
)

const (
	pkgNats  = "github.com/nats-io/nats.go"
	pkgNrpc  = "github.com/emm035/nrpc/go/pkg/nrpc"
	pkgProto = "google.golang.org/protobuf/proto"
	pkgAnypb = "google.golang.org/protobuf/types/known/anypb"
)

var (
	requestWrapper = parse.Type{
		Package: "github.com/emm035/nrpc/go/pkg/nrpc",
		Name:    "RequestWrapper",
	}
	responseWrapper = parse.Type{
		Package: "github.com/emm035/nrpc/go/pkg/nrpc",
		Name:    "ResponseWrapper",
	}
	responseWrapperOk = parse.Type{
		Package: "github.com/emm035/nrpc/go/pkg/nrpc",
		Name:    "ResponseWrapper_Ok",
	}
	responseWrapperErr = parse.Type{
		Package: "github.com/emm035/nrpc/go/pkg/nrpc",
		Name:    "ResponseWrapper_Err",
	}
)

const (
	clientName       = "client"
	serverName       = "server"
	dataName         = "data"
	dataPbName       = "datapb"
	requestName      = "request"
	requestWrapName  = "requestwrap"
	responseErrName  = "err"
	responseMsgName  = "resmsg"
	responseName     = "response"
	responseOkName   = "ok"
	responseWrapName = "responsewrap"
)

type Generator struct {
	Vtproto bool
}

func (gen *Generator) GenerateFiles(files ...parse.File) error {
	genpool := pool.New().WithErrors().WithFirstError()
	for _, file := range files {
		genpool.Go(func() error {
			return gen.generate(file)
		})
	}
	return genpool.Wait()
}

func (gen *Generator) generate(filedef parse.File) error {
	file := jen.NewFile(filedef.Package)

	// Declare import mappings
	file.HeaderComment("Code generated by nrpc; DO NOT EDIT.")
	file.ImportName(pkgNats, "nats")
	file.ImportName(pkgNrpc, "nrpc")
	file.ImportName(pkgProto, "proto")
	file.ImportName(pkgAnypb, "anypb")

	for _, service := range filedef.Services {
		gen.serviceInterface(file, service)
		gen.clientConstructor(file, service)
		gen.clientImpl(file, service)
		gen.serverConstructor(file, service)
		gen.serverImpl(file, service)
	}

	return file.Render(filedef)
}

func (gen *Generator) serviceInterface(file *jen.File, service parse.Service) {
	file.Type().Id(service.Name).InterfaceFunc(func(g *jen.Group) {
		for _, method := range service.Methods {
			g.Id(method.Name).Params(gen.typeName(method.Input, true)).Params(gen.typeName(method.Output, true), jen.Error())
		}
	}).Line()
}

func (gen *Generator) clientConstructor(file *jen.File, service parse.Service) {
	file.Func().Id("New"+service.Name+"Client").Params(
		jen.Id("conn").Op("*").Qual(pkgNats, "Conn"),
		jen.Id("options").Op("...").Qual(pkgNrpc, "ClientOption"),
	).Params(jen.Id(service.Name), jen.Error()).BlockFunc(func(g *jen.Group) {
		g.List(jen.Id("clientOptions"), jen.Err()).Op(":=").Qual(pkgNrpc, "NewClientOptions").Params(jen.Id("options").Op("..."))
		g.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		)
		g.Line()
		g.Return(jen.Op("&").Add(gen.clientTypeName(service, false)).Values(jen.Dict{
			jen.Id("options"): jen.Id("clientOptions"),
			jen.Id("conn"):    jen.Id("conn"),
		}), jen.Nil())
	})
}

func (gen *Generator) clientImpl(file *jen.File, service parse.Service) {
	// Client struct definition
	file.Type().Add(gen.clientTypeName(service, false)).Struct(
		jen.Id("options").Op("*").Qual(pkgNrpc, "ClientOptions"),
		jen.Id("conn").Op("*").Qual(pkgNats, "Conn"),
	)

	// Client method definitions
	for _, method := range service.Methods {
		gen.clientMethod(file, service, method)
		file.Line()
	}
}

func (gen *Generator) clientMethod(file *jen.File, service parse.Service, method parse.Method) {
	file.Add(gen.clientMethodSignature(service, method)).BlockFunc(func(g *jen.Group) {
		gen.clientMethodBody(g, service, method)
	})
}

func (gen *Generator) clientMethodSignature(service parse.Service, method parse.Method) *jen.Statement {
	return jen.Func().
		Params(jen.Id("client").Add(gen.clientTypeName(service, true))).
		Id(method.Name).
		Params(jen.Id("request").Add(gen.typeName(method.Input, true))).
		Params(gen.typeName(method.Output, true), jen.Error())
}

func (gen *Generator) clientMethodBody(group *jen.Group, service parse.Service, method parse.Method) {
	group.Id(requestWrapName).Op(":=").New(gen.typeName(requestWrapper, false))
	group.Line()
	group.List(jen.Id(dataPbName), jen.Err()).Op(":=").Qual(pkgAnypb, "New").Params(jen.Id(requestName))
	group.If(jen.Err().Op("!=").Nil()).Block(
		jen.Return(jen.Nil(), jen.Err()),
	)
	group.Id(requestWrapName).Dot("Data").Op("=").Id(dataPbName)
	group.Line()
	if gen.Vtproto {
		group.List(jen.Id(dataName), jen.Err()).Op(":=").Id(requestWrapName).Dot("MarshalVT").Params()
	} else {
		group.List(jen.Id(dataName), jen.Err()).Op(":=").Qual(pkgProto, "Marshal").Params(jen.Id(requestWrapName))
	}
	group.If(jen.Err().Op("!=").Nil()).Block(
		jen.Return(jen.Nil(), jen.Err()),
	)
	group.Line()
	group.List(jen.Id(responseMsgName), jen.Err()).Op(":=").Id(clientName).Dot("conn").Dot("Request").Params(
		gen.natsSubject(clientName, service, method),
		jen.Id(dataName),
		jen.Id(clientName).Dot("options").Dot("Timeout"),
	)
	group.If(jen.Err().Op("!=").Nil()).Block(
		jen.Return(jen.Nil(), jen.Err()),
	)
	group.Line()
	group.Id(responseWrapName).Op(":=").New(gen.typeName(responseWrapper, false))
	group.If(
		jen.Err().Op(":=").Id(responseWrapName).Dot("UnmarshalVT").Params(jen.Id(responseMsgName).Dot("Data")),
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Return(jen.Nil(), jen.Err()),
	)
	group.Line()
	group.Switch(jen.Id(responseName).Op(":=").Id(responseWrapName).Dot("Data").Dot("").Params(jen.Type())).BlockFunc(func(group *jen.Group) {
		group.Case(gen.typeName(responseWrapperOk, true))
		group.Id(responseOkName).Op(":=").New(gen.typeName(method.Output, false))
		group.If(
			jen.Err().Op(":=").Id(responseName).Dot("Ok").Dot("UnmarshalTo").Params(jen.Id(responseOkName)),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Return(jen.Nil(), jen.Err()),
		)
		group.Return(jen.Id(responseOkName), jen.Nil())
		group.Case(gen.typeName(responseWrapperErr, true))
		group.Return(jen.Nil(), jen.Qual("errors", "New").Params(jen.Id(responseName).Dot("Err")))
		group.Default()
		group.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Params(jen.Lit("unsupported response type: %T"), jen.Id(responseName)))
	})
}

func (gen *Generator) serverConstructor(file *jen.File, service parse.Service) {
	file.Func().Id("New"+service.Name+"Server").Params(
		jen.Id("conn").Op("*").Qual(pkgNats, "Conn"),
		jen.Id("service").Id(service.Name),
		jen.Id("options").Op("...").Qual(pkgNrpc, "ServerOption"),
	).Params(jen.Qual(pkgNrpc, "Server"), jen.Error()).BlockFunc(func(g *jen.Group) {
		g.List(jen.Id("serverOptions"), jen.Err()).Op(":=").Qual(pkgNrpc, "NewServerOptions").Params(jen.Id("options").Op("..."))
		g.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		)
		g.Line()
		g.Return(jen.Op("&").Add(gen.serverTypeName(service, false)).Values(
			jen.Dict{
				jen.Id("options"): jen.Id("serverOptions"),
				jen.Id("service"): jen.Id("service"),
				jen.Id("conn"):    jen.Id("conn"),
			},
		), jen.Nil())
	})
}

func (gen *Generator) serverImpl(file *jen.File, service parse.Service) {
	// Server struct definition
	file.Type().Add(gen.serverTypeName(service, false)).Struct(
		jen.Id("options").Op("*").Qual(pkgNrpc, "ServerOptions"),
		jen.Id("service").Id(service.Name),
		jen.Id("conn").Op("*").Qual(pkgNats, "Conn"),
		jen.Comment("Internal only fields"),
		jen.Id("lock").Qual("sync", "Mutex"),
		jen.Id("stop").Chan().Struct(),
		jen.Id("errs").Chan().Error(),
	)

	// Server implementation
	file.Line()
	gen.serverStartStopMethods(file, service)
	file.Line()

	// Server method definitions
	for _, method := range service.Methods {
		gen.serverHandler(file, service, method)
		file.Line()
	}
}

func (gen *Generator) serverStartStopMethods(file *jen.File, service parse.Service) {
	file.Func().Params(jen.Id(serverName).Add(gen.serverTypeName(service, true))).Id("Start").Params().Error().BlockFunc(func(g *jen.Group) {
		g.Id(serverName).Dot("lock").Dot("Lock").Params()
		g.Defer().Id(serverName).Dot("lock").Dot("Unlock").Params()
		g.Line()
		g.Comment("We're already running, so don't do anything")
		g.If(jen.Id(serverName).Dot("stop").Op("!=").Nil()).Block(
			jen.Return(jen.Nil()),
		)
		g.Line()
		g.Comment("Create a stop signal channel")
		g.Id(serverName).Dot("stop").Op("=").Make(jen.Chan().Struct())
		g.Line()

		g.Comment("Create a channel for handling errors.")
		g.Id(serverName).Dot("errs").Op("=").Make(jen.Chan().Error())
		g.Go().Func().Params().Block(
			jen.For(jen.Err().Op(":=").Range().Id(serverName).Dot("errs")).Block(
				jen.Comment("Only do something if we have an error handler"),
				jen.If(jen.Id(serverName).Dot("options").Dot("ErrorHandler").Op("!=").Nil()).Block(
					jen.Id(serverName).Dot("options").Dot("ErrorHandler").Params(jen.Id("err")),
				),
			),
		).Params()
		g.Line()
		for _, method := range service.Methods {
			g.Commentf("Start %s server loop", method.Name)
			g.If(
				jen.Err().Op(":=").Id(serverName).Dot("startSubscription").Params(
					gen.natsSubject(serverName, service, method),
					jen.Id(serverName).Dot("serve"+strcase.ToCamel(method.Name)),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Close(jen.Id(serverName).Dot("stop")),
				jen.Close(jen.Id(serverName).Dot("errs")),
				jen.Return(jen.Err()),
			)
			g.Line()
		}
		g.Line()
		g.Return(jen.Nil())
	})
	file.Line()
	file.Commentf("Stop the RPC server that wraps %s", service.Name)
	file.Func().Params(jen.Id(serverName).Add(gen.serverTypeName(service, true))).Id("Stop").Params().Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id(serverName).Dot("lock").Dot("Lock").Params()
		g.Defer().Id(serverName).Dot("lock").Dot("Unlock").Params()
		g.Line()
		g.Comment("We're not running, so do nothing.")
		g.If(jen.Id(serverName).Dot("stop").Op("==").Nil()).Block(
			jen.Return(jen.Nil()),
		)
		g.Line()
		g.Comment("Stop all workers, clean up subscriptions")
		g.Close(jen.Id(serverName).Dot("stop"))
		g.Close(jen.Id(serverName).Dot("errs"))
		g.Id(serverName).Dot("stop").Op("=").Nil()
		g.Id(serverName).Dot("errs").Op("=").Nil()
		g.Return(jen.Nil())
	})
	file.Line()
	file.Func().Params(jen.Id(serverName).Add(gen.serverTypeName(service, true))).Id("startSubscription").Params(
		jen.Id("subject").String(),
		jen.Id("handler").Func().Params(jen.Op("*").Qual("github.com/nats-io/nats.go", "Msg")),
	).Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("msgs").Op(":=").Make(jen.Chan().Op("*").Qual("github.com/nats-io/nats.go", "Msg"), jen.Id(serverName).Dot("options").Dot("BufferSize"))
		g.Line()
		g.List(jen.Id("sub"), jen.Err()).Op(":=").Id(serverName).Dot("conn").Dot("ChanQueueSubscribe").Params(jen.Id("subject"), jen.Id(serverName).Dot("options").Dot("QueueGroup"), jen.Id("msgs"))
		g.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Err()),
		)
		g.Qual("fmt", "Println").Params(jen.Lit("Listening on:"), jen.Id("subject"))
		g.Line()

		g.Comment("Remove the subscription and clean up when")
		g.Comment("the stop channel is closed")
		g.Go().Func().Params().Block(
			jen.Op("<-").Id(serverName).Dot("stop"),
			jen.If(jen.Err().Op(":=").Id("sub").Dot("Unsubscribe").Params(), jen.Err().Op("!=").Nil()).Block(
				jen.Id(serverName).Dot("errs").Op("<-").Err(),
			),
			jen.Close(jen.Id("msgs")),
		).Params()
		g.Line()

		g.Go().Func().Params().BlockFunc(func(g *jen.Group) {
			g.Comment("Handle incoming server messages")
			g.For(jen.Id("msg").Op(":=").Range().Id("msgs")).Block(
				jen.Id("handler").Params(jen.Id("msg")),
			)
		}).Params()

		g.Return(jen.Nil())
	})
}

func (gen *Generator) serverHandler(file *jen.File, service parse.Service, method parse.Method) {
	file.Func().Params(
		jen.Id(serverName).Add(gen.serverTypeName(service, true)),
	).Add(gen.serverHandlerName(method)).Params(
		jen.Id("msg").Op("*").Qual(pkgNats, "Msg"),
	).BlockFunc(func(g *jen.Group) {
		g.Id(requestName).Op(":=").New(gen.typeName(method.Input, false))
		g.Id(requestWrapName).Op(":=").New(gen.typeName(requestWrapper, false))
		g.Id(responseWrapName).Op(":=").New(gen.typeName(responseWrapper, false))
		g.Line()
		g.If(
			jen.Err().Op(":=").Id(requestWrapName).Dot("UnmarshalVT").Params(jen.Id("msg").Dot("Data")),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id(responseWrapName).Dot("Data").Op("=").Op("&").Add(gen.typeName(responseWrapperErr, false)).Values(jen.Dict{
				jen.Id("Err"): jen.Err().Dot("Error").Params(),
			}),
			jen.Id(serverName).Dot("errs").Op("<-").Err(),
		).Else().If(
			jen.Err().Op(":=").Qual(pkgAnypb, "UnmarshalTo").Params(
				jen.Id(requestWrapName).Dot("Data"),
				jen.Id(requestName),
				jen.Qual(pkgProto, "UnmarshalOptions").Values(),
			),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id(responseWrapName).Dot("Data").Op("=").Op("&").Add(gen.typeName(responseWrapperErr, false)).Values(jen.Dict{
				jen.Id("Err"): jen.Err().Dot("Error").Params(),
			}),
			jen.Id(serverName).Dot("errs").Op("<-").Err(),
		).Else().If(
			jen.List(jen.Id(responseName), jen.Err()).Op(":=").Id(serverName).Dot("service").Dot(method.Name).Params(
				jen.Id(requestName),
			),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id(responseWrapName).Dot("Data").Op("=").Op("&").Add(gen.typeName(responseWrapperErr, false)).Values(jen.Dict{
				jen.Id("Err"): jen.Err().Dot("Error").Params(),
			}),
			jen.Id(serverName).Dot("errs").Op("<-").Err(),
		).Else().If(
			jen.List(jen.Id(dataPbName), jen.Err()).Op(":=").Qual(pkgAnypb, "New").Params(jen.Id(responseName)),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id(responseWrapName).Dot("Data").Op("=").Op("&").Add(gen.typeName(responseWrapperErr, false)).Values(jen.Dict{
				jen.Id("Err"): jen.Err().Dot("Error").Params(),
			}),
			jen.Id(serverName).Dot("errs").Op("<-").Err(),
		).Else().Block(
			jen.Id(responseWrapName).Dot("Data").Op("=").Op("&").Add(gen.typeName(responseWrapperOk, false)).Values(jen.Dict{
				jen.Id("Ok"): jen.Id(dataPbName),
			}),
		)
		g.Line()
		g.Comment("Send our response back")
		g.If(
			jen.List(jen.Id(dataName), jen.Err()).Op(":=").Id(responseWrapName).Dot("MarshalVT").Params(),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id(serverName).Dot("errs").Op("<-").Err(),
		).Else().If(
			jen.Err().Op(":=").Id("msg").Dot("Respond").Params(jen.Id(dataName)),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id(serverName).Dot("errs").Op("<-").Err(),
		)
	})
}

func (gen *Generator) serverHandlerName(method parse.Method) jen.Code {
	return jen.Id("serve" + strcase.ToCamel(method.Name))
}

func (gen *Generator) natsSubject(container string, service parse.Service, method parse.Method) jen.Code {
	return jen.Qual("fmt", "Sprintf").Params(
		jen.Lit(fmt.Sprintf("%%s.%s.%s", service.Name, method.Name)),
		jen.Id(container).Dot("options").Dot("Namespace"),
	)
}

func (gen *Generator) typeName(typ parse.Type, pointer bool) jen.Code {
	stmt := jen.Add()
	if pointer {
		stmt = stmt.Op("*")
	}
	if typ.Package != "" {
		return stmt.Qual(typ.Package, typ.Name)
	} else {
		return stmt.Id(typ.Name)
	}
}

func (gen *Generator) clientTypeName(service parse.Service, pointer bool) jen.Code {
	stmt := jen.Add()
	if pointer {
		stmt = stmt.Op("*")
	}
	return stmt.Id(strcase.ToLowerCamel(service.Name) + "Client")
}

func (gen *Generator) serverTypeName(service parse.Service, pointer bool) jen.Code {
	stmt := jen.Add()
	if pointer {
		stmt = stmt.Op("*")
	}
	return stmt.Id(strcase.ToLowerCamel(service.Name) + "Server")
}
