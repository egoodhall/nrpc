package astutil

import (
	"fmt"
	"os"
	"text/template"

	_ "embed"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"golang.org/x/tools/go/packages"
)

// Declare shared/reused types
var (
	natsConn = jen.Id("conn").Add(jen.Op("*")).Qual("github.com/nats-io/nats.go", "Conn")
)

//go:embed common.gotmpl
var common string
var commontmpl = template.Must(template.New("").Parse(common))

func Render(pkg *packages.Package, svc Service) error {
	file, err := os.OpenFile("nrpc.gen.go", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := commontmpl.Execute(file, pkg); err != nil {
		return err
	}

	file, err = os.OpenFile(svc.FileName(), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	// Set up our file first
	f := jen.NewFile(pkg.Name)
	f.HeaderComment("Code generated by nrpc; DO NOT EDIT.")
	f.ImportName("github.com/nats-io/nats.go", "nats")

	renderResponseWrappers(f, svc)
	renderSpecificErrorTypes(f, svc)
	renderClient(f, svc)
	renderServer(f, svc)

	return f.Render(file)
}

func renderResponseWrappers(f *jen.File, svc Service) {
	for _, mth := range svc.Methods {
		f.Commentf("Response wrapper type for %s.%s", svc.Name, mth.Name)
		f.Type().Id(mth.ResponseTypeName(svc)).StructFunc(func(g *jen.Group) {
			if mth.Response != nil {
				g.Id("Res").Add(mth.Response.Render(""))
			}
			g.Id("Err").Error()
		})
		f.Line()
	}
}

func renderSpecificErrorTypes(f *jen.File, svc Service) {
	for _, mth := range svc.Methods {
		f.Type().Id(mth.ErrorTypeName(svc)).Struct(
			jen.Id("Message").String(),
		)
		f.Line()
		f.Func().Params(jen.Id("err").Op("*").Id(mth.ErrorTypeName(svc))).Id("Error").Params().Params(jen.String()).Block(
			jen.Return(jen.Qual("fmt", "Sprintf").Params(jen.Lit(fmt.Sprintf("%s.%s: %%s", svc.Name, mth.Name)), jen.Err().Dot("Message"))),
		)
		f.Line()
		f.Func().Params(jen.Id("err").Op("*").Id(mth.ErrorTypeName(svc))).Id("Is").Params(jen.Id("other").Error()).Params(jen.Bool()).Block(
			jen.List(jen.Id("_"), jen.Id("is")).Op(":=").Id("other").Assert(jen.Op("*").Id(mth.ErrorTypeName(svc))),
			jen.Return(jen.Id("is")),
		)
	}
	f.Line()
	f.Func().Id("init").Params().BlockFunc(func(g *jen.Group) {
		for _, mth := range svc.Methods {
			g.Qual("encoding/gob", "Register").Params(jen.New(jen.Id(mth.ErrorTypeName(svc))))
		}
	})
}

func renderClient(f *jen.File, svc Service) {
	// Declare our client implementation as a package-private struct
	f.Commentf("Client for accessing %s over NATS RPC", svc.Name)
	f.Type().Id(svc.ClientStructName()).Struct(
		jen.Id("options").Op("*").Id("ClientOptions"),
		natsConn,
	)

	// Constructor for our client implementation
	f.Commentf("Create a new client that transparently accesses %s over NATS RPC", svc.Name)
	f.Func().Id("New"+svc.Name+"Client").Params(
		natsConn,
		jen.Id("options").Op("...").Id("ClientOpt"),
	).Params(
		jen.Id(svc.Name),
		jen.Error(),
	).Block(
		jen.Id("opts").Op(":=").Op("&").Id("ClientOptions").Values(jen.Dict{
			jen.Id("Timeout"): jen.Lit(10).Op("*").Qual("time", "Second"),
		}),
		jen.For(jen.List(jen.Op("_"), jen.Id("option")).Op(":=").Range().Id("options")).Block(
			jen.If(jen.Err().Op(":=").Id("option").Dot("setClient").Params(jen.Id("opts")), jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Err()),
			),
		),
		jen.Return(jen.Op("&").Id(svc.ClientStructName()).Values(jen.Dict{
			jen.Id("options"): jen.Id("opts"),
			jen.Id("conn"):    jen.Id("conn"),
		}), jen.Nil()),
	)

	// Render all methods
	for _, method := range svc.Methods {
		f.Commentf("Implements %s.%s", svc.Name, method.Name)
		f.Add(method.RenderForClient(svc))
	}
}

func renderServer(f *jen.File, svc Service) {
	// Common statements
	service := jen.Id("service").Id(svc.Name)

	// Declare our client implementation as an unexported struct
	f.Commentf("Expose a %s implementation over NATS RPC", svc.Name)
	f.Type().Id(svc.ServerStructName()).Struct(
		jen.Id("options").Op("*").Id("ServerOptions"),
		service,
		natsConn,
		jen.Comment("Internal-only fields"),
		jen.Id("lock").Qual("sync", "Mutex"),
		jen.Id("stop").Chan().Struct(),
		jen.Id("errs").Chan().Error(),
	)

	// Constructor for our client implementation
	f.Commentf("Create a new server that exposes %s over NATS RPC", svc.Name)
	f.Func().Id("New"+svc.Name+"Server").Params(
		service,
		natsConn,
		jen.Id("options").Op("...").Id("ServerOpt"),
	).Params(
		jen.Id("Server"),
		jen.Error(),
	).Block(
		jen.Id("opts").Op(":=").New(jen.Id("ServerOptions")),
		jen.For(jen.List(jen.Op("_"), jen.Id("option")).Op(":=").Range().Id("options")).Block(
			jen.If(jen.Err().Op(":=").Id("option").Dot("setServer").Params(jen.Id("opts")), jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Err()),
			),
		),
		jen.Line(),
		jen.Return(jen.Op("&").Id(svc.ServerStructName()).Values(jen.Dict{
			jen.Id("options"): jen.Id("opts"),
			jen.Id("service"): jen.Id("service"),
			jen.Id("conn"):    jen.Id("conn"),
		}), jen.Nil()),
	)
	f.Line()

	// Server start method
	f.Commentf("Start the RPC server that wraps %s", svc.Name)
	f.Func().Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).Id("Start").Params().Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("server").Dot("lock").Dot("Lock").Params()
		g.Defer().Id("server").Dot("lock").Dot("Unlock").Params()
		g.Line()
		g.Comment("We're already running, so don't do anything")
		g.If(jen.Id("server").Dot("stop").Op("!=").Nil()).Block(
			jen.Return(jen.Nil()),
		)
		g.Line()
		g.Comment("Create a stop signal channel")
		g.Id("server").Dot("stop").Op("=").Make(jen.Chan().Struct())
		g.Line()

		g.Comment("Create a channel for handling errors.")
		g.Id("server").Dot("errs").Op("=").Make(jen.Chan().Error())
		g.Go().Func().Params().Block(
			jen.For(jen.Err().Op(":=").Range().Id("server").Dot("errs")).Block(
				jen.Comment("Only do something if we have an error handler"),
				jen.If(jen.Id("server").Dot("options").Dot("ErrorHandler").Op("!=").Nil()).Block(
					jen.Id("server").Dot("options").Dot("ErrorHandler").Params(jen.Id("err")),
				),
			),
		).Params()
		g.Line()
		for _, mth := range svc.Methods {
			g.If(
				jen.Err().Op(":=").Id("server").Dot(fmt.Sprintf("run%sServerLoop", svc.Name)).Params(
					jen.Id("server").Dot("options").Dot("Namespace").Op("+").Lit(fmt.Sprintf("%s.%s", svc.Name, mth.Name)),
					jen.Id("server").Dot(strcase.ToLowerCamel(mth.Name)),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Close(jen.Id("server").Dot("stop")),
				jen.Close(jen.Id("server").Dot("errs")),
				jen.Return(jen.Err()),
			)
		}
		g.Line()
		g.Return(jen.Nil())
	})
	f.Line()

	// Server stop method
	f.Commentf("Stop the RPC server that wraps %s", svc.Name)
	f.Func().Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).Id("Stop").Params().Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("server").Dot("lock").Dot("Lock").Params()
		g.Defer().Id("server").Dot("lock").Dot("Unlock").Params()
		g.Line()
		g.Comment("We're not running, so do nothing.")
		g.If(jen.Id("server").Dot("stop").Op("==").Nil()).Block(
			jen.Return(jen.Nil()),
		)
		g.Line()
		g.Comment("Stop all workers, clean up")
		g.Close(jen.Id("server").Dot("stop"))
		g.Id("server").Dot("stop").Op("=").Nil()
		g.If(jen.Id("server").Dot("options").Dot("ErrorHandler").Op("!=").Nil()).Block(
			jen.Close(jen.Id("server").Dot("errs")),
		)
		g.Return(jen.Nil())
	})
	f.Line()

	// Server loop function
	f.Func().Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).Id(fmt.Sprintf("run%sServerLoop", svc.Name)).Params(
		jen.Id("subject").String(),
		jen.Id("handler").Func().Params(jen.Op("*").Qual("github.com/nats-io/nats.go", "Msg")),
	).Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("msgs").Op(":=").Make(jen.Chan().Op("*").Qual("github.com/nats-io/nats.go", "Msg"), jen.Id("server").Dot("options").Dot("BufferSize"))
		g.List(jen.Id("sub"), jen.Err()).Op(":=").Id("server").Dot("conn").Dot("ChanSubscribe").Params(jen.Id("subject"), jen.Id("msgs"))
		g.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Err()),
		)
		g.Qual("fmt", "Println").Params(jen.Lit("Listening on:"), jen.Id("subject"))
		g.Line()

		g.Comment("Remove the subscription and clean up when")
		g.Comment("the stop channel is closed")
		g.Go().Func().Params().Block(
			jen.Op("<-").Id("server").Dot("stop"),
			jen.If(jen.Err().Op(":=").Id("sub").Dot("Unsubscribe").Params(), jen.Err().Op("!=").Nil()).Block(
				jen.Id("server").Dot("errs").Op("<-").Err(),
			),
			jen.Close(jen.Id("msgs")),
		).Params()
		g.Line()

		g.Go().Func().Params().BlockFunc(func(g *jen.Group) {
			g.Comment("Handle incoming server messages")
			g.For(jen.Id("msg").Op(":=").Range().Id("msgs")).Block(
				jen.Id("handler").Params(jen.Id("msg")),
			)
		}).Params()

		g.Return(jen.Nil())
	})

	// Render all methods
	for _, method := range svc.Methods {
		f.Commentf("Exposes %s.%s via NATS RPC", svc.Name, method.Name)
		f.Add(method.RenderForServer(svc))
	}
}
