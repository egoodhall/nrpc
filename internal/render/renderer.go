package render

import (
	"fmt"
	"os"
	"text/template"

	_ "embed"

	"github.com/dave/jennifer/jen"
	"github.com/emm035/nrpc/internal/astutil"
	"golang.org/x/tools/go/packages"
)

// Declare shared/reused types
var (
	natsConn = jen.Id("conn").Add(jen.Op("*")).Qual("github.com/nats-io/nats.go", "Conn")
)

//go:embed nrpc.go.tmpl
var common string
var commontmpl = template.Must(template.New("").Parse(common))

type Renderer struct {
	Client   bool
	Server   bool
	Encoding string
}

func (rnd *Renderer) Render(pkg *packages.Package, svc astutil.Service) error {
	file, err := os.OpenFile("nrpc.gen.go", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := commontmpl.Execute(file, pkg); err != nil {
		return err
	}

	file, err = os.OpenFile(svc.FileName(), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	// Set up our file first
	f := jen.NewFile(pkg.Name)
	f.HeaderComment("Code generated by nrpc; DO NOT EDIT.")
	f.ImportName("github.com/nats-io/nats.go", "nats")

	rnd.renderResponseWrappers(f, svc)
	rnd.renderSpecificErrorTypes(f, svc)
	if rnd.Client {
		rnd.renderClient(f, svc)
	}
	if rnd.Server {
		rnd.renderServer(f, svc)
	}

	return f.Render(file)
}

func (rnd *Renderer) renderResponseWrappers(f *jen.File, svc astutil.Service) {
	for _, mth := range svc.Methods {
		f.Commentf("Response wrapper type for %s.%s", svc.Name, mth.Name)
		f.Type().Id(mth.ResponseTypeName(svc)).StructFunc(func(g *jen.Group) {
			if mth.Response != nil {
				g.Id("Ok").Add(rnd.renderField(*mth.Response, "")).Tag(map[string]string{"json": "ok"})
			}
			g.Id("Err").Op("*").Id(mth.ErrorTypeName(svc)).Tag(map[string]string{"json": "err"})
		})
		f.Line()
	}
}

func (rnd *Renderer) renderSpecificErrorTypes(f *jen.File, svc astutil.Service) {
	for _, mth := range svc.Methods {
		f.Type().Id(mth.ErrorTypeName(svc)).Struct(
			jen.Id("Message").String(),
		)
		f.Line()
		f.Func().Params(jen.Id("err").Op("*").Id(mth.ErrorTypeName(svc))).Id("Error").Params().Params(jen.String()).Block(
			jen.Return(jen.Qual("fmt", "Sprintf").Params(jen.Lit(fmt.Sprintf("%s.%s: %%s", svc.Name, mth.Name)), jen.Err().Dot("Message"))),
		)
		f.Line()
		f.Func().Params(jen.Id("err").Op("*").Id(mth.ErrorTypeName(svc))).Id("Is").Params(jen.Id("other").Error()).Params(jen.Bool()).Block(
			jen.List(jen.Id("_"), jen.Id("is")).Op(":=").Id("other").Assert(jen.Op("*").Id(mth.ErrorTypeName(svc))),
			jen.Return(jen.Id("is")),
		)
	}

	if rnd.Encoding == "gob" {
		f.Line()
		f.Func().Id("init").Params().BlockFunc(func(g *jen.Group) {
			for _, mth := range svc.Methods {
				g.Qual("encoding/gob", "Register").Params(jen.New(jen.Id(mth.ErrorTypeName(svc))))
			}
		})
	}
}

func (rnd *Renderer) renderClient(f *jen.File, svc astutil.Service) {
	// Declare our client implementation as a package-private struct
	f.Commentf("Client for accessing %s over NATS RPC", svc.Name)
	f.Type().Id(svc.ClientStructName()).Struct(
		jen.Id("options").Op("*").Id("ClientOptions"),
		natsConn,
	)

	// Constructor for our client implementation
	f.Commentf("Create a new client that transparently accesses %s over NATS RPC", svc.Name)
	f.Func().Id("New"+svc.Name+"Client").Params(
		natsConn,
		jen.Id("options").Op("...").Id("ClientOpt"),
	).Params(
		jen.Id(svc.Name),
		jen.Error(),
	).Block(
		jen.Id("opts").Op(":=").Op("&").Id("ClientOptions").Values(jen.Dict{
			jen.Id("Timeout"): jen.Lit(10).Op("*").Qual("time", "Second"),
		}),
		jen.For(jen.List(jen.Op("_"), jen.Id("option")).Op(":=").Range().Id("options")).Block(
			jen.If(jen.Err().Op(":=").Id("option").Dot("setClient").Params(jen.Id("opts")), jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Err()),
			),
		),
		jen.Return(jen.Op("&").Id(svc.ClientStructName()).Values(jen.Dict{
			jen.Id("options"): jen.Id("opts"),
			jen.Id("conn"):    jen.Id("conn"),
		}), jen.Nil()),
	)

	// Render all methods
	for _, mth := range svc.Methods {
		f.Commentf("Implements %s.%s", svc.Name, mth.Name)
		f.Add(rnd.renderClientMethod(svc, mth))
	}
}

func (rnd *Renderer) renderServer(f *jen.File, svc astutil.Service) {
	// Common statements
	service := jen.Id("service").Id(svc.Name)

	// Declare our client implementation as an unexported struct
	f.Commentf("Expose a %s implementation over NATS RPC", svc.Name)
	f.Type().Id(svc.ServerStructName()).Struct(
		jen.Id("options").Op("*").Id("ServerOptions"),
		service,
		natsConn,
		jen.Comment("Internal-only fields"),
		jen.Id("lock").Qual("sync", "Mutex"),
		jen.Id("stop").Chan().Struct(),
		jen.Id("errs").Chan().Error(),
	)

	// Constructor for our client implementation
	f.Commentf("Create a new server that exposes %s over NATS RPC", svc.Name)
	f.Func().Id("New"+svc.Name+"Server").Params(
		service,
		natsConn,
		jen.Id("options").Op("...").Id("ServerOpt"),
	).Params(
		jen.Id("Server"),
		jen.Error(),
	).Block(
		jen.Id("opts").Op(":=").New(jen.Id("ServerOptions")),
		jen.For(jen.List(jen.Op("_"), jen.Id("option")).Op(":=").Range().Id("options")).Block(
			jen.If(jen.Err().Op(":=").Id("option").Dot("setServer").Params(jen.Id("opts")), jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Err()),
			),
		),
		jen.Line(),
		jen.Return(jen.Op("&").Id(svc.ServerStructName()).Values(jen.Dict{
			jen.Id("options"): jen.Id("opts"),
			jen.Id("service"): jen.Id("service"),
			jen.Id("conn"):    jen.Id("conn"),
		}), jen.Nil()),
	)
	f.Line()

	// Server start method
	f.Commentf("Start the RPC server that wraps %s", svc.Name)
	f.Func().Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).Id("Start").Params().Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("server").Dot("lock").Dot("Lock").Params()
		g.Defer().Id("server").Dot("lock").Dot("Unlock").Params()
		g.Line()
		g.Comment("We're already running, so don't do anything")
		g.If(jen.Id("server").Dot("stop").Op("!=").Nil()).Block(
			jen.Return(jen.Nil()),
		)
		g.Line()
		g.Comment("Create a stop signal channel")
		g.Id("server").Dot("stop").Op("=").Make(jen.Chan().Struct())
		g.Line()

		g.Comment("Create a channel for handling errors.")
		g.Id("server").Dot("errs").Op("=").Make(jen.Chan().Error())
		g.Go().Func().Params().Block(
			jen.For(jen.Err().Op(":=").Range().Id("server").Dot("errs")).Block(
				jen.Comment("Only do something if we have an error handler"),
				jen.If(jen.Id("server").Dot("options").Dot("ErrorHandler").Op("!=").Nil()).Block(
					jen.Id("server").Dot("options").Dot("ErrorHandler").Params(jen.Id("err")),
				),
			),
		).Params()
		g.Line()
		for _, mth := range svc.Methods {
			g.Commentf("Start %s server loop", mth.Name)
			g.If(
				jen.Err().Op(":=").Id("server").Dot("_serve").Params(
					jen.Id("server").Dot("options").Dot("Namespace").Op("+").Lit(mth.NatsSubject(svc)),
					jen.Id("server").Dot(mth.HandlerName()),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Close(jen.Id("server").Dot("stop")),
				jen.Close(jen.Id("server").Dot("errs")),
				jen.Return(jen.Err()),
			)
			g.Line()
		}
		g.Line()
		g.Return(jen.Nil())
	})
	f.Line()

	// Server stop method
	f.Commentf("Stop the RPC server that wraps %s", svc.Name)
	f.Func().Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).Id("Stop").Params().Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("server").Dot("lock").Dot("Lock").Params()
		g.Defer().Id("server").Dot("lock").Dot("Unlock").Params()
		g.Line()
		g.Comment("We're not running, so do nothing.")
		g.If(jen.Id("server").Dot("stop").Op("==").Nil()).Block(
			jen.Return(jen.Nil()),
		)
		g.Line()
		g.Comment("Stop all workers, clean up subscriptions")
		g.Close(jen.Id("server").Dot("stop"))
		g.Close(jen.Id("server").Dot("errs"))
		g.Id("server").Dot("stop").Op("=").Nil()
		g.Id("server").Dot("errs").Op("=").Nil()
		g.Return(jen.Nil())
	})
	f.Line()

	// Server loop function
	f.Func().Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).Id("_serve").Params(
		jen.Id("subject").String(),
		jen.Id("handler").Func().Params(jen.Op("*").Qual("github.com/nats-io/nats.go", "Msg")),
	).Params(jen.Error()).BlockFunc(func(g *jen.Group) {
		g.Id("msgs").Op(":=").Make(jen.Chan().Op("*").Qual("github.com/nats-io/nats.go", "Msg"), jen.Id("server").Dot("options").Dot("BufferSize"))
		g.List(jen.Id("sub"), jen.Err()).Op(":=").Id("server").Dot("conn").Dot("ChanSubscribe").Params(jen.Id("subject"), jen.Id("msgs"))
		g.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Err()),
		)
		g.Qual("fmt", "Println").Params(jen.Lit("Listening on:"), jen.Id("subject"))
		g.Line()

		g.Comment("Remove the subscription and clean up when")
		g.Comment("the stop channel is closed")
		g.Go().Func().Params().Block(
			jen.Op("<-").Id("server").Dot("stop"),
			jen.If(jen.Err().Op(":=").Id("sub").Dot("Unsubscribe").Params(), jen.Err().Op("!=").Nil()).Block(
				jen.Id("server").Dot("errs").Op("<-").Err(),
			),
			jen.Close(jen.Id("msgs")),
		).Params()
		g.Line()

		g.Go().Func().Params().BlockFunc(func(g *jen.Group) {
			g.Comment("Handle incoming server messages")
			g.For(jen.Id("msg").Op(":=").Range().Id("msgs")).Block(
				jen.Id("handler").Params(jen.Id("msg")),
			)
		}).Params()

		g.Return(jen.Nil())
	})

	// Render all methods
	for _, mth := range svc.Methods {
		f.Commentf("Exposes %s.%s via NATS RPC", svc.Name, mth.Name)
		f.Add(rnd.renderServerMethod(svc, mth))
	}
}

func (rnd *Renderer) renderClientMethod(svc astutil.Service, mth astutil.Method) *jen.Statement {
	return rnd.renderClientSignature(svc, mth).BlockFunc(func(g *jen.Group) {
		if mth.Request != nil {
			// We have a request type, so we need to encode it.
			g.Commentf("Encode request data from %s using gob", mth.Request.Type)
			g.Id("buf").Op(":=").New(jen.Qual("bytes", "Buffer"))
			g.IfFunc(func(g *jen.Group) {
				encode := jen.Err().Op(":=").Qual(rnd.encImport(), "NewEncoder").Params(jen.Id("buf")).Dot("Encode")
				if mth.Request.Pointer {
					g.Add(encode.Params(jen.Id(mth.Request.NameOrDefault("request"))))
				} else {
					g.Add(encode.Params(jen.Op("&").Id(mth.Request.NameOrDefault("request"))))
				}
				g.Err().Op("!=").Nil()
			}).BlockFunc(func(g *jen.Group) {
				if mth.Response == nil {
					g.Return(jen.Err())
				} else {
					if mth.Response.Pointer {
						g.Return(jen.Nil(), jen.Err())
					} else {
						g.Return(jen.Id("response"), jen.Err())
					}
				}
			})
			g.Line()
		}

		// Send the actual request
		g.Commentf("Send RPC message to %s.%s", svc.Name, mth.Name)
		g.List(jen.Id("msg"), jen.Err()).Op(":=").Id("client").Dot("conn").Dot("Request").ParamsFunc(func(g *jen.Group) {
			g.Add(jen.Id("client").Dot("options").Dot("Namespace").Op("+").Lit(mth.NatsSubject(svc)))
			if mth.Request != nil {
				g.Add(jen.Id("buf").Dot("Bytes").Params())
			} else {
				g.Add(jen.Nil())
			}
			g.Id("client").Dot("options").Dot("Timeout")
		})

		g.If(jen.Err().Op("!=").Nil()).BlockFunc(func(g *jen.Group) {
			if mth.Response == nil {
				g.Add(jen.Return(jen.Err()))
			} else if mth.Response.Pointer {
				g.Add(jen.Return(jen.Nil(), jen.Err()))
			} else {
				g.Add(jen.Return(jen.Id("response"), jen.Err()))
			}
		})
		g.Line()

		// We have a response that we need to decode
		g.Commentf("Decode response into a wrapper object")
		g.Var().Id("reswrap").Id(mth.ResponseTypeName(svc))
		g.If(
			jen.Err().Op(":=").Qual(rnd.encImport(), "NewDecoder").Params(jen.Qual("bytes", "NewReader").Params(jen.Id("msg").Dot("Data"))).Dot("Decode").Params(jen.Op("&").Id("reswrap")),
			jen.Err().Op("!=").Nil(),
		).BlockFunc(func(g *jen.Group) {
			if mth.Response == nil {
				g.Return(jen.Err())
			} else if mth.Response.Pointer {
				g.Return(jen.Nil(), jen.Err())
			} else {
				g.Return(jen.Id("response"), jen.Err())
			}
		})

		// Return our decoded response values
		g.Line()
		if mth.Response == nil {
			g.If(jen.Id("reswrap").Dot("Err").Op("!=").Nil()).Block(
				jen.Return(jen.Id("reswrap").Dot("Err")),
			)
			g.Return(jen.Nil())
		} else {
			g.If(jen.Id("reswrap").Dot("Err").Op("!=").Nil()).Block(
				jen.Return(jen.Id("reswrap").Dot("Ok"), jen.Id("reswrap").Dot("Err")),
			)
			g.Add(jen.Return(jen.Id("reswrap").Dot("Ok"), jen.Nil()))
		}
	})
}

func (rnd *Renderer) renderClientSignature(svc astutil.Service, mth astutil.Method) *jen.Statement {
	return jen.Func().Params(jen.Id("client").Op("*").Id(svc.ClientStructName())).Id(mth.Name).
		// Parameters for our method
		ParamsFunc(func(g *jen.Group) {
			if mth.Request != nil {
				g.Add(rnd.renderField(*mth.Request, "request"))
			}
		}).
		// Response types for our method
		ParamsFunc(func(g *jen.Group) {
			if mth.Response != nil {
				g.Add(rnd.renderField(*mth.Response, "response"))
			}
			g.Err().Error()
		})
}

func (rnd *Renderer) renderServerMethod(svc astutil.Service, mth astutil.Method) *jen.Statement {
	return rnd.renderServerSignature(svc, mth).BlockFunc(func(g *jen.Group) {
		g.Defer().Func().Params().Block(
			jen.If(jen.Id("val").Op(":=").Recover(), jen.Id("val").Op("!=").Nil()).Block(
				jen.If(jen.List(jen.Err(), jen.Id("ok")).Op(":=").Id("val").Assert(jen.Error()), jen.Id("ok")).Block(
					jen.Id("server").Dot("errs").Op("<-").Err(),
				),
			),
		).Params()
		if mth.Request != nil {
			g.Var().Id("request").Id(mth.Request.Type)
		}
		g.Var().Id("response").Id(mth.ResponseTypeName(svc))

		stmt := jen.Add()
		if mth.Request != nil {
			// We have a request type, so we need to decode it
			// before we can call the service method
			stmt = jen.If(
				jen.Err().Op(":=").Qual(rnd.encImport(), "NewDecoder").Params(jen.Qual("bytes", "NewReader").Params(jen.Id("msg").Dot("Data"))).Dot("Decode").Params(jen.Op("&").Id("request")),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Id("errw").Op(":=").Op("&").Id(mth.ErrorTypeName(svc)).Values(jen.Err().Dot("Error").Params()),
				jen.Id("response").Dot("Err").Op("=").Id("errw"),
				jen.Id("server").Dot("errs").Op("<-").Id("errw"),
			).Else()
		}

		// Now we can make the service call
		stmt = stmt.If(
			jen.ListFunc(func(g *jen.Group) {
				if mth.Response != nil {
					g.Id("res")
				}
				g.Err()
			}).Op(":=").Id("server").Dot("service").Dot(mth.Name).ParamsFunc(func(g *jen.Group) {
				if mth.Request != nil {
					g.Id("request")
				}
			}),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id("errw").Op(":=").Op("&").Id(mth.ErrorTypeName(svc)).Values(jen.Err().Dot("Error").Params()),
			jen.Id("response").Dot("Err").Op("=").Id("errw"),
			jen.Id("server").Dot("errs").Op("<-").Id("errw"),
		)

		// If we are expecting a response, we should set it
		// on the response wrapper if there wasn't an error
		// returned from the service method.
		if mth.Response != nil {
			stmt = stmt.Else().Block(
				jen.Id("response").Dot("Ok").Op("=").Id("res"),
			)
		}
		g.Add(stmt)
		g.Line()

		// Next, we need to encode our response wrapper, and
		// send our response. This should be the same behavior
		// regardless of whether our method gives a response.
		g.Id("buf").Op(":=").New(jen.Qual("bytes", "Buffer"))
		g.If(
			jen.Err().Op(":=").Qual(rnd.encImport(), "NewEncoder").Params(jen.Id("buf")).Dot("Encode").Params(jen.Id("response")),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id("server").Dot("errs").Op("<-").Op("&").Id(mth.ErrorTypeName(svc)).Values(jen.Err().Dot("Error").Params()),
		).Else().If(
			jen.Err().Op(":=").Id("msg").Dot("Respond").Params(jen.Id("buf").Dot("Bytes").Params()),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Id("server").Dot("errs").Op("<-").Op("&").Id(mth.ErrorTypeName(svc)).Values(jen.Err().Dot("Error").Params()),
		)
	})
}

func (rnd *Renderer) renderServerSignature(svc astutil.Service, mth astutil.Method) *jen.Statement {
	return jen.Func().
		Params(jen.Id("server").Op("*").Id(svc.ServerStructName())).
		Id(mth.HandlerName()).
		Params(jen.Id("msg").Op("*").Qual("github.com/nats-io/nats.go", "Msg"))
}

func (rnd *Renderer) renderField(nf astutil.NamedField, defaultName string) *jen.Statement {
	stmt := jen.Add()
	if defaultName != "" {
		stmt = stmt.Id(nf.NameOrDefault(defaultName))
	}
	if nf.Pointer {
		stmt = stmt.Op("*")
	}
	if nf.Pkg != nil {
		return stmt.Qual(*nf.Pkg, nf.Type)
	}
	return stmt.Id(nf.Type)
}

func (rnd *Renderer) encImport() string {
	return fmt.Sprintf("encoding/%s", rnd.Encoding)
}
